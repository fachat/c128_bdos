



         ;../WP1 2.4 .S96 ==0801==
menuprg   lda #0
          sta $9d              ; error meldung unterbinden
          jsr sortinit
          jsr convinit
          jsr mprtinit
          lda #"0"
          sta iecdrive
          lda menubcol
          jsr setbck
          lda menutcol
          jsr settxt
          lda #8             ;"{dish}"
          jsr wout
          lda #142
          jsr wout
         ;********
mprg      lda #<mainmenu
          ldy #>mainmenu
          jsr wminit
          jsr version
          txa 
          clc 
          adc #vetext
          bcc mver1
          iny 
mver1     jsr wprnterr
mp3       jsr stline
          jsr wclrcmd
          lda #7
          jsr wout
          jsr wmenloop
mp2       txa 
          pha 
          tya 
          pha 
          jsr wclrerr
          pla 
          tay 
          pla 
          asl 
          tax 
          jsr mp1
          cmp #0
          beq mp3
          jsr fehlout
          jmp mp3
fehlout   pha 
          jsr wclrerr
          pla 
          jsr errtxt
          jmp wprnterr
mp1       lda mpma+1,x
          pha 
          lda mpma,x
          pha 
          rts 
mpm1      tya 
          asl 
          tax 
          lda mpm1a+1,x
          pha 
          lda mpm1a,x
          pha 
          rts 
mpm2      tya 
          asl 
          tax 
          lda mpm2a+1,x
          pha 
          lda mpm2a,x
          pha 
          rts 
mpm3      tya 
          asl 
          tax 
          lda mpm3a+1,x
          pha 
          lda mpm3a,x
          pha 
          rts 
mpm4      tya 
          asl 
          tax 
          lda mpm4a+1,x
          pha 
          lda mpm4a,x
          pha 
          rts 
mpm5      tya 
          asl 
          tax 
          lda mpm5a+1,x
          pha 
          lda mpm5a,x
          pha 
          rts 
mpr       clc 
          rts 
         ;**** copyrights
mpm11     jsr version
          txa 
          clc 
          adc #vetext
          bcc mver2
          iny 
mver2     jsr wprnterr
          lda #<coptxt
          ldy #>coptxt
          jsr wopenmsg
mpm11a    jsr wgetkey
          cmp #13
          bne mpm11a
          jsr wclose
          lda #0
          rts 
         ;**** colours
mpm12     lda #<coltxt
          ldy #>coltxt
          jsr wopenmsg
mpm12d    lda menubcol
          jsr setbck
          lda menutcol
          jsr settxt
mpm12a    jsr wgetkey
          beq mpm12a
          cmp #29             ; "{rght}"
          bne mpm12b
          inc menubcol
          jmp mpm12d
mpm12b    cmp #29+128    ;"{left}"
          bne mpm12c
          dec menubcol
          jmp mpm12d
mpm12c    cmp #17          ;"{down}"
          bne mpm12e
          inc menutcol
          jmp mpm12d
mpm12e    cmp #17+128    ;"{up}"
          bne mpm12f
          dec menutcol
          jmp mpm12d
mpm12f    cmp #13
          bne mpm12a
          jsr wclose
          lda #0
m14a      rts 
         ;********
mpm14     jsr asksure
          bcs m14a
          jsr exit
          jmp ($fffc)
         ;********
mpm13     
#if fci
	lda #ennotimp
	rts
#else
          pla 
          pla 
          jsr wclose
          jsr wclr
          jmp cliprg
         ;********
#endif
mpm28     
#if fci
	lda #ennotimp
	rts
#else
          lda #9
          jsr prntcmd
          lda #<mbeft
          ldy #>mbeft
          jsr winput
          bcc m27nff
          rts 
m27nff    stx czei
          sty czei+1
          jsr sbef
          beq m27nf
          cmp #maxmenu+1
          bcs m27nf
          jsr exec
          rts 
m27nf     lda #ennotimp
          rts 
         ;******** cbmunit
#endif
mpm32     lda #11
          jsr prntcmd
          ldx #0
          lda #<m32mt
          ldy #>m32mt
          jsr wsubmenu
m32b      jsr wsubloop
m32a      cmp #13
          bne m32b
          tya 
          clc 
          adc #8
          cmp #12
          bcc m32c
          clc 
          adc #"0"-13
          sta iecdrive
          jmp m32d
m32c      sta iecunit
m32d      jsr wclose
          lda #0
          rts 
         ;**** cbmcommand
mpm34     lda #9
          jsr prntcmd
          lda #<m34t
          ldy #>m34t
          jsr winput
          bcc mpm34x
          rts 
mpm34x    jsr setfnpar
          lda #1
          ldx iecunit
          ldy #15
          jsr setfpar
          jsr open
          ora #64
          bcs m34c
          jsr m34b
          lda #0
m34c      pha 
          jsr clrch
m34c1     lda #1
          jsr close
          pla 
          rts 
m34b      ldx #1
          jsr chkin
          ora #64
          bcs m34c
          ldy #0
          sty status
m34a      jsr basin
          cmp #13
          beq m34aa
          sta iobuf,y
          iny 
m34aa     lda status
          beq m34a
          lda #0
          sta iobuf,y
          jsr clrch
          jsr wclrerr
          lda #<iobuf
          ldy #>iobuf
          jsr wprnterr
          lda iobuf
          cmp #"0"
          bne m34y
          lda #0
          rts 
m34y      lda #eneof
          rts 
         ;******** (cbmcatalog)
	; prepare the directory open filename ($0mask)
ismcbm  .(
	; output to enter search mask  
	; use search mask to create
	; CBM directory read mask in iobuf
	; e.g. "$0:foo"
	  lda #1
          jsr prntcmd
	; get input with "mask:" as prompt
	; returns x/y address of name, a has len
          lda #<ismct
          ldy #>ismct
          jsr winput
          bcc ismcx
          rts 
ismcx   ; save len
	  pha 
	; add space for "$0:" in front of name 
          cmp #0
          bne ismc3
          lda #1
ismc3     clc 
          adc #3
	; set file name parameters
          jsr setfnpar
	; pull orig len from stack to X
	; use extended len in Y
          tay 
          pla 
          pha 
          tax 
	; copy over filename to the extended place
	; to make space for $0:
ismc1     lda iobuf,x
          sta iobuf,y
          dey 
          dex 
          bpl ismc1
	; length of file
          pla 
          bne ismc2
	; if no filename given, just add "*" has wildcard
          sta iobuf+4
          lda #"*"
          sta iobuf+3
	; add the directory name "$" and drive in front
ismc2     lda #"$"
          sta iobuf
          lda iecdrive
          sta iobuf+1
          lda #":"
          sta iobuf+2
          clc 
          rts 
         ;****
	.)
	.(
m31err    jmp m31i1
         ;****
	; read in a CBM directory, display it
	; and let the user select a file
&gtcbmdir 
	; enter search mask and prepare open filename for directory
	; in iobuf.
	  jsr ismcbm
          bcc gtcbm1
          rts 
gtcbm1    lda #19          ;"{home}"
          jsr wout
	; set file parameter for CBM kernal
          lda #1
          ldx iecunit
          ldy #0
          jsr setfpar
	; open file
          jsr open
	; translate error code
          ora #64
          bcs m31err
	; set input from file
          ldx #1
          jsr chkin
          ora #64
          bcs m31err
	; read directory
	; load address
          jsr basin
          jsr basin
	; link address 1st line (volume name)
          jsr basin
          jsr basin
	; low byte drive
          jsr basin
          pha 
	; high byte drive is always zero
          jsr basin
          pla 
          and #15
          clc 
	; store drive and rest of volumne name into iobuf
          adc #"0"
          sta iobuf
          lda #" "
          sta iobuf+1
          ldy #2
m31a      jsr basin
	; special (ctrl) char? esp. 12 = REV
          cmp #" "
          bcc m31b
          sta iobuf,y
          iny 
m31b      
          ldx status
          beq m31aa
	; error detected, close and display not ready
          lda #0
          sta iobuf,y
          lda #endnrdy
          bne m31err
	; skip special char
m31aa     cmp #0
          bne m31a
	; end volume info
          sta iobuf,y

	; initialize list pointer	
          lda #<liste
          sta lzei
          lda #>liste
          sta lzei+1
	; number of entries is zero
          lda #0
          sta lanz
	; get list entry
	; append it to liste which is pointed to by (lzei)
m31e      jsr getencbm
          bcs m31c
	; advance list entry in (lzei)
          lda #dirlistentrylen
          clc 
          adc lzei
          sta lzei
          bcc m31d
          inc lzei+1
	; increase number of entries
m31d      inc lanz
	; check if we reached the end of available memory
          jsr testlist
          bcc m31e
	; directory list full error
          lda #32
          jmp m31i1
	
	; end of list reached
	; lzei points to last entry
m31c      ldy #0
          lda (lzei),y
          sta int1
          iny 
          lda (lzei),y
          sta int1+1

	; iobuf has the volume info
	; find end of it	
          ldx #0
m31f      lda iobuf,x
          beq m31g
          inx 
          bne m31f
m31g  	; append "," to mask
	  lda #","
          sta iobuf,x
          inx 
	; print out size (in int1) to iobuf,x
          jsr getdez
	; print blocks free message
          ldy #0
m31h      lda m31bft,y
          sta iobuf,x
          beq m31i
          iny 
          inx 
          bne m31h
m31i      lda #0
m31i1     
	; close dir file
          pha 
          jsr clrch
          lda #1
          jsr close
          pla 
	; check for error
          bne m31sor
          ldx #0
          ldy lanz
          beq m31sor0
          dey 
          lda #0
	; sort the list
          jsr sort
m31sor0   lda #0
m31sor    rts 
	.)
         ;****
	; get an entry from a CBM directory
	; stores the entry in (lzei), where
	; first two bytes are size (in blocks)
	; then up to 16 chars filename
	; then zero terminator
	; then type (single byte at position 19)
	; so list entry is 20 bytes (dirlistentrylen)
getencbm  .(
	  jsr basin		; link address low
          jsr basin             ; kettenadresse (link address) high
          ldy #0
          jsr basin		; file size in blocks, lo
          sta (lzei),y
          iny 
          jsr basin		; file size in blocks, hi
          sta (lzei),y
          iny 
	; skip until quote
gec1      jsr basin
          cmp #34
          beq gec2
          lda status
          beq gec1
          bne gecr
	; store filename in list buffer
gec2      jsr basin
          cmp #34
          beq gec4a
          cmp #" "
          bcs gec3
	; non-printable (ctrl) chars are converted (64 is added)
          adc #"@"
gec3      sta (lzei),y
	; max length check (should add * at the end at some point TODO)
	cpy #dirlistentrylen-2
	bcs gec3a
	iny
gec3a
          lda status
          beq gec2
          bne gecr
	; end of filename, terminate entry
gec4a     lda #0
          sta (lzei),y
	; wait until extension
gec4      jsr basin
          cmp #" "
          bne gec5
          lda status
          beq gec4
          bne gecr
	; store in list (after max filename plus zero terminator)
gec5      ldy #19
          sta (lzei),y
	; ensure filename is zero-terminated
          lda #0
          dey 
          sta (lzei),y
	; skip till end of line for directory entry
gec6      jsr basin
          cmp #0
          beq gec7
          lda status
          beq gec6
gecr      sec 
          rts 
gec7      clc 
          rts 
	.)
         ;****
	; prepare a page of a CBM directory 
	; store the page to output in direntry+4
inimlist  .(
	; page number
	  lda lseit
          sta int1
          lda #0
          sta int1+1
	; number of entries per page
          lda #mdiranz
          ldx #0
	; multiply
          jsr mult
	; to get actual dir entry
          sta int1
	; are we still in limits?
          lda lanz
          sec 
          sbc int1
          cmp #mdiranz
          bcc iml1
          ;beq iml1	; does not matter
          lda #mdiranz
iml1    ; number of entries on page  
	  sta dirmenu
          sta lmanz
	; width of dir page "menu"
          lda #mdirtbrt
          sta dirmenu+1
	; position of menu on screen
          lda #3
          sta dirmenu+2
          lda #6
          sta dirmenu+3
	; calculate pointer to entry in liste
          lda #0
          sta int1+1
          lda #dirlistentrylen
          ldx #0
          jsr mult
          clc 
          adc #<liste
          sta lzei
          txa 
          adc #>liste
          sta lzei+1
	; pointer to?
          lda #<dirmenu+4
          sta lmzei
          lda #>dirmenu+4
          sta lmzei+1
	; start in iobuf
iml2      lda #" "
          sta iobuf
          sta iobuf+1
          sta iobuf+2
	; copy filename of dir entr to iobuf
          ldy #2
iml3      lda (lzei),y
          beq iml4
          sta iobuf+1,y
          iny 
          cpy #18
          bne iml3
	; fill with space
iml4      lda #" "
iml5      cpy #19
          beq iml6
          sta iobuf+1,y
          iny 
          bne iml5
iml6      sta iobuf+21
	; copy over file type
          lda (lzei),y
          sta iobuf+1,y
	; is selected?
          ldy #18
          lda (lzei),y
          bpl iml6a
	; set marker if selected
          lda #">"
          sta iobuf+1
iml6a   ; output the file size  
	  ldy #0
          lda (lzei),y
          sta int1
          iny 
          lda (lzei),y
          sta int1+1
          ldx #22
          jsr getdez
	; fill with spaces
          lda #" "
iml7      sta iobuf,x
          cpx #mdirtbrt-1
          beq iml8
          inx 
          bne iml7
	; store calculated entry into lmzei (dirmenu)
iml8      ldy #mdirtbrt
iml9      lda iobuf-1,y
          sta (lmzei),y
          dey 
          bne iml9
          lda #128
          sta (lmzei),y
	; advance to next entry
          lda lzei
          clc 
          adc #dirlistentrylen
          sta lzei
          bcc iml10
          inc lzei+1
iml10     
          lda lmzei
          clc 
          adc #mdirtbrt+1
          sta lmzei
          bcc iml11
          inc lmzei+1
iml11   ; are we done yet?  
	dec lmanz
	bne iml2
          rts
	.) 
         ;********
	; read a directory and display it
catalog .(
	  jsr gtcbmdir
          beq mpm31x
          rts 
mpm31x  ; print the iobuf with volume and bytes free on the bottom
	  lda #<iobuf
          ldy #>iobuf
          jsr wprnterr
	; do we have any file at all?
          lda lanz
          bne mpm31y
          rts 
mpm31y  ; output "stop, ret to end"  
	  lda #10
          jsr prntcmd
	
          lda #0
	; jmp mpdirin
	.)
	; fall-through
	;
	; read directory, display it, and optionally
	; allow selecting one or multiple files
mpdirin .(
	  sta mpdf
	; page for the dir listing (page with crsr left/right)
          lda #0
          sta lseit
          .byt $2c
mp31a1    lda #128
          pha 
	; prepare a page of files in dirmenu+4 (dirmenu has the submenu)
          jsr inimlist
	; create submenu and print it
          pla 
          ora #32
          tax 
          lda #<dirmenu
          ldy #>dirmenu
          jsr wsubmenu
	; char entry
mp31a     jsr wsubloop
mp31al    cmp #29          ;"{rght}"
          beq mp31aa
          cmp #17             ;"{down}"
          bne mp31b

mp31aa  ; next page (exit with right or down)
	  lda lseit
          sta int1
          inc int1
          lda #0
          sta int1+1
          lda #mdiranz
          ldx #0
          jsr mult
          cpx #0
          bne mp31a
          cmp lanz
          bcs mp31a
          inc lseit
          bne mp31a1

mp31b     cmp #29+128    ;"{left}"
          beq mp31ba
          cmp #17+128       ;"{up}"
          bne mp31c
mp31ba  ; previous page (exit with up or left)
	  lda lseit
          beq mp31a
          dec lseit
          jmp mp31a1

	; test further chars
mp31c     cmp #"="	; select
          beq mp31d
          cmp #"#"	; select
          beq mp31d
          cmp #3	; Ctrl-C / STOP
          beq mp31e
          cmp #13	; CR
          bne mp31a	; back to loop
	; mpdirin option
          bit mpdf	; if bit 6 is set, select/CR goes to execute
          bvs mp31xx

mp31e   ; end of directory
	  pha 
          jsr wclose
          jsr wclrerr
          pla 
          cmp #3
          beq mp31ea
          lda #0
          rts 
mp31ea    lda #enbreak
          rts 

mp31d   ; select a file
	  lda mpdf
          bpl mp31e	; if positive, select ends

	; store selected	
          sty sma
	; multiply page with entries per page
          lda lseit
          sta int1
          lda #0
          sta int1+1
          lda #mdiranz
          ldx #0
          jsr mult
	; add entry in page
          clc 
          adc sma
          sta int1
          bcc mp31f
          inx 
mp31f   ; multiply with size of list entry
	  stx int1+1
          lda #dirlistentrylen
          ldx #0
          jsr mult
	; add base address and store as pointer to file
          clc 
          adc #<liste
          sta lzei
          txa 
          adc #>liste
          sta lzei+1
          ldy #18
          lda (lzei),y
          eor #$80		; mark as selected / deselected
          sta (lzei),y
	; make entry in menu list
          ldy #2
          lda (lmzei),y
          eor #$1e
          sta (lmzei),y
	; check option
          bit mpdf
          bvc mp31xx
	; if set, end directory at first selected
          lda #0		
          beq mp31e		; always - end of directory
mp31xx    
          lda #17             ;"{down}"
          jsr wexloop		; execute "down" command (smdown)
          jmp mp31al
	.)
         ;********

mpm33     jsr gtcbmdir
          beq mpm33x
          rts 
mpm33x    lda #<iobuf
          ldy #>iobuf
          jsr wprnterr
          lda lanz
          bne mpm33y
          rts 
mpm33y    lda #7
          jsr prntcmd
          lda #128
          jsr mpdirin
          beq mpm33ya
          rts 
mpm33ya   lda #<liste
          sta lzei
          lda #>liste
          sta lzei+1
          jsr asksure
          bcc mp33a
          rts 
mp33a     lda #"s"
          sta iobuf
          lda iecdrive
          sta iobuf+1
          lda #":"
          sta iobuf+2
          ldy #18
          lda (lzei),y
          bpl mp33c
          ldy #2
mp33d     lda (lzei),y
          sta iobuf+1,y
          beq mp33b
          iny 
          cpy #18
          bne mp33d
          lda #0
          sta iobuf+1,y
mp33b     iny 
          tya 
          ldx #<iobuf
          ldy #>iobuf
          jsr setfnpar
          lda #1
          ldx iecunit
          ldy #15
          jsr setfpar
          jsr open
          jsr m34b
          pha 
          lda #1
          jsr close
          pla 
          beq mp33c
          jsr errorq
          bcs mp33ee
mp33c     lda lzei
          clc 
          adc #dirlistentrylen
          sta lzei
          bcc mp33e
          inc lzei+1
mp33e     dec lanz
          bne mp33a
mp33ee    lda #0
          rts 
         ;********
asksure   lda #<ast
          ldy #>ast
          jsr wopenmsg
as1       jsr wgetkey
          beq as1
          cmp #13
          beq as2
          cmp #3
          bne as1
          jsr wclose
          sec 
          lda #enbreak
          rts 
as2       jsr wclose
          clc 
          rts 
         ;********
ertxrx    lda #entxrx
          .byt $2c
ernotimp  lda #ennotimp
          rts 
         ;****
	; takes int1, and prints it out in decimal into iobuf
getdez    .(
	  ldy #0
          stx gdb
go1       lda dhi,y
          tax 
          lda dlo,y
	; divide int1 by a/x; return result in a/x and rest in int1 (keeps y)
          jsr ddiv
          iny 
          cmp #0
          bne go2
          cpy #4
          bne go1
          beq go3
go2       clc 
          adc #"0"
          ldx gdb
          sta iobuf,x
          inc gdb
go3       lda dhi,y
          tax 
          lda dlo,y
          jsr ddiv
          clc 
          adc #"0"
          ldx gdb
          sta iobuf,x
          inc gdb
          iny 
          cpy #5
          bcc go3
          ldx gdb
          rts 
	.)
         ;********
stline    ldx #23
          ldy #0
          clc 
          jsr wcursor
          ldy #39
          lda #" "
stl0      jsr wout
          dey 
          bne stl0
          ldx #23
          ldy #0
          clc 
          jsr wcursor
          lda #<stlt1
          ldy #>stlt1
          jsr textout
          lda iecdrive
          jsr wout
          lda #","
          jsr wout
          lda #"u"
          jsr wout
          ldx iecunit
          cpx #10
          bcc stl1
          txa 
          sec 
          sbc #10
          tax 
          lda #"1"
          .byt $2c
stl1      lda #" "
          jsr wout
          txa 
          clc 
          adc #"0"
          jsr wout
          lda #<stlt2
          ldy #>stlt2
          jsr textout
          clc 
          jsr sgdrive
          clc 
          adc #"A"             ;"a"
          jsr wout
          lda #":"
          jsr wout
          jsr gtpath
          sta lmzei
          sty lmzei+1
          ldy #2
stl3      lda (lmzei),y
          beq stl4
          jsr wout
          iny 
          cpy #stlend
          bne stl3
stl4      rts 
         ;********
