



                                  BDOS V1.31 


                         Anleitung für Programmierer


    Mit diesem Programmpaket können Sie auf einfache Weise IBM-Disketten
    auf Ihrem Commodore 128 mit VC1571 verwalten, lesen und beschreiben.


    Das Programm BDOS kann mit der Floppy VC1571 ein- und doppelseitige
    IBM-Disketten mit 40 Tracks , also IBM-Disketten mit 180 bzw 360 kByte
    lesen und beschreiben.
    Aufgeteilt ist das Programm in 2 Teile: Die Shell "PROMPT" und das
    'Betriebssystem' "BDOS". Optional ist die "RAMDISK" verfügbar, die
    einen Speicherplatz von 227 Blocks aus BANK 1 des C128 bietet.
    Außerdem die Programme "SHOW.RWABS" und "SHOW.FLOPRW", die sich in die
    entsprechenden Routinen einklinken und die Parameter des Aufrufs auf
    dem Bildschirm anzeigen. Die drei letztgenannten Programme kann man
    mit dem Befehl "SYS" aktivieren. Die Ramdisk wird aber auch direkt
    beim starten mit "RUN ME" aktiviert.
    Alle Teile sind komplett in Maschinensprache geschrieben. Alle
    Programme liegen in Bank 0. Laden und Speichern ist bei DREAD/DWRITE
    sowie RWABS und FLOPRW in eine beliebige Bank möglich. Dabei wird als
    Parameter für die Bank der Wert angegeben, der in das Configuration
    Register geschrieben wird.




                                  PROMPT 2.1 




    Das Programm PROMPT 2.1 haben Sie schon im ersten Teil der
    Beschreibung kennengelernt. Es bildet die Schnittstelle zwischen
    Benutzer und eigentlichem Betriebssystem. D.h. es wertet die
    Tastaturkommandos aus und führt sie unter Zuhilfenahme des
    Betriebssystems "BDOS" aus. Um das Programm zu starten, muß BDOS
    bereits initialisiert sein. Dann wird das Programm mit             
    JSR STARTADRESSE gestartet. Ein Aufruf aus Basic ist nicht möglich, da
    BDOS eine Speicherkonfiguration herstellt und zum Betrieb erwartet, in
    der das Basic-ROM nicht verfügbar ist.




                                  BDOS 1.42 



    Das Programm BDOS ist das eigentlich Betriebssystem, das den
    Datenverkehr mit der Floppy regelt.



                                    - 7 -
     





    Um es auch bei späteren [nderungen noch kompatibel zu halten, werden
    alle Routinen über eine JUMP-Tabelle angesprungen, wobei die meisten
    der Jumps indirekt, d.h. über eine Adresstabelle geführt sind.
    Initialisiert wird BDOS durch JSR STARTADRESSE. Dann stehen die in
    Tabelle 9 aufgeführten Routinen zur Verfügung. Doch vorher etwas
    Allgemeines:
    Fast alle Routinen liefern einen Fehlercode zurück. Bei Fehler ist das
    ZERO-Flag gelöscht, d.h. man schreibt am einfachsten nach dem
    JSR-Befehl "BNE FEHLERROUTINE". Außerdem enthält der Akkumulator den
    Fehlercode, den Sie Tabelle 1 entnehmen können.

    In Tabelle 2 finden Sie die Routinen mit Adresse relativ zur
    Startadresse, Name, Direkt oder indirekter Sprung und
    Kurzbeschreibung.



     Aufbau der Diskette 



    Wie ist nun so eine Diskette aufgebaut, mit der das Programm
    fertigwerden muß? 
    Für die physikalische Verteilung auf der Diskette ist der
    Disk-Controller WD1770 in der VC1571 zuständig. Dieses IC ist ein
    Standardprodukt und wird, in abgewandelter Form, z.B. auch im Atari ST
    benutzt.
    Die Diskette wird, um Speicherplatz zu gewinnen und lästiges Umdrehen
    zu verhindern, im allgemeinen zweiseitig beschrieben.
    [ltere IBM (-Kompatible) Laufwerke können nur einseitig lesen und
    schreiben. Doch auch BDOS bietet dies und damit die Möglichkeit, mit
    einseitigen Disketten Daten auszutauschen.
    Der Schreib-Lese-Kopf des Laufwerks (bei doppelseitigen Laufwerken je
    einer pro Seite) kann im 'Fenster' der Diskette in bestimmten
    Abständen hin- und herfahren. Er belegt beim Schreiben nur einen
    kleinen radialen Streifen auf der Diskette, der auch Spur oder 'Track'
    genannt wird. Die Abstände, mit denen der Schreib-Lese-Kopf hin- und
    her fährt, bestimmen die Anzahl der Spuren auf der Diskette und damit
    die Speicherkapazität; je größer die Abstände, desto weniger
    Speicherplatz. Dieser Abstand hängt von verschiedenen Faktoren ab,
    unter anderem von der Breite des Schreib-Lese-Kopfes. Früher konnte
    man nur 40 Spuren auf eine Diskette bringen, heute Dank verbesserter
    Technologie schon 80 und mehr. Die VC1570/1571 bieten dem Anwender nur
    die Möglichkeit, 40 Spuren zu benutzen, aber die 'großen' Laufwerke
    mit 80 Spuren können normalerweise 40-Spur Disketten mindestens Lesen.
    Jede Spur ist wiederum aufgeteilt in einzelne Sektoren, die auf der
    einen Spur wie auf einer Perlenkette hintereinandergereiht sind. Im
    allgemeinen werden 9 Sektoren pro Spur verwendet, andere Formate sind
    möglich.
    Der Sektor besteht aus einem Vorspann, in dem u.a. zur Identifikation
    der Track (Spur) und die Nummer des Sektors auf der Spur enthalten
    sind. Dann folgen die Datenbytes, deren Anzahl von Diskette zu
    Diskette unterschiedlich sein kann. Das Ganze wird mit einer
    Checksumme, mit der der Controller feststellt, ob die Daten korrekt
    sind, abgesichert.
    Man kann also die Daten auf einer Diskette mit der Angabe von  Seite ,
     Spur  und  Sektor  auf der Spur genau lokalisieren. Dies ist in der
    BDOS-Funktion FLOPRW realisiert, bei der man den entsprechenden Sektor
    laden oder schreiben kann.




                                    - 8 -
     





    Die Nummerierung im IBM-Format erfolgt nach folgendem Schema: 
    Seite 0 (Unterseite) oder Seite 1 (Oberseite)
    Track 0 (außen) bis Track 40 (oder 80, innen)
    Sektor 1 bis Sektor 9 (oder auch 8 oder 10)
    Wie findet sich der Controller einerseits und BDOS andererseits in
    dieser Vielfalt von möglichen Formaten zurecht? Für den Controller
    existiert der Befehl QUERY, mit dem er sich auf das aktuelle
    Diskettenformat einstellt. Deshalb muß dieser Befehl nach jedem
    Disketten-Wechsel ausgeführt werden. Dieser Befehl bringt aber nur den
    Track, die Sektorgröße und die Anzahl Sektoren pro Spur als
    Information zurück. Für BDOS reicht das nicht aus. Mit diesen
    Informationen kann man aber schon den Befehl geben, den einen Sektor
    zu lesen, der auf allen Disketten an der gleichen Stelle liegt: Seite
    0, Track 0 und Sektor 1. Dieser Sektor wird vom IBM-DOS und somit von
    BDOS dazu benutzt, alle notwendigen Informationen über das Format
    aufzuzeichnen. Für den IBM besteht noch die Möglichkeit, in diesem
    Sektor ein Boot-Programm unterzubringen, das sofort nach laden des
    Sektors gestartet wird. Der Boot-Sektor ist in Tabelle 4 dargestellt.
    Die Daten sind allerdings in einer Form abgespeichert, die für das
    System nicht optimal ist. Deshalb berechnet man mit der Routine GETBPB
    den sogenannten BIOS-PARAMETER-BLOCK (BPB, Tabelle 5), der die
    erforderlichen Daten in vernünftigerer Form enthält. Die Routine
    GETBPB lädt nur den Boot-Sektor und berechnet den BPB. Für die Arbeit
    mit Verzeichnissen und Dateien muß der BPB über die Routine SGDRIVE
    aktualisiert werden. Damit werden alle relevanten Daten für
    Verzeichnisse (Pfad), Dateien und Pufferverwaltung übernommen.
    Andernfalls kann es zu Datenverlusten kommen! 
    Um den Zugriff auf die Diskette zu erleichtern und den [rger mit den
    verschiedenen Formaten zu umgehen, führt man eine logische
    Sektornummer ein. Diese logische Sektornummer ist die Adresse des
    Sektors auf der Diskette, wie sie von der Routine RWABS benötigt wird.
    Der Anwender hat sich nicht mehr mit den Parametern Seite, Track und
    Sektor herumzuschlagen. Für ihn existiert nur noch eine Sektornummer
    von 0 bis BTSEC-1 (Anzahl Sektoren aus dem Boot-Sektor). Die
    Nummerierung erfolgt so:
    logSektor=Track*BPSPTS+Seite*BPSPT+Sektor-1
    (BPSPTS und BPSPT aus dem BPB)
    D.h. daß zuerst die Unterseite und dann die Oberseite des Tracks
    gelesen wird und dann auf den nächsten Track gesprungen wird.
    Damit wäre der Sektormäßige Zugriff geklärt. Die Diskette mit
    Directory und Files benötigt aber noch weitere Informationen, da auch
    dort verschiedene Formate existieren. Dazu werden Ihnen bestimmt
    verschiedene Werte im Boot-Sektor oder BPB aufgefallen sein.
    Nach Tabelle 3 kommt in der Reihenfolge der logischen Sektornummer
    nach dem Boot-Sektor die FILE-ALLOCATION-TABLE (FAT), doch dazu kommen
    wir später. Vor den Daten folgt dann noch das Hauptverzeichnis. Dessen
    Größe wird von BTDIR im Boot-Sektor festgelegt. Dieser Wert gibt die
    Anzahl der möglichen Einträge oder Dateien im Hauptverzeichnis an.
    Jeder Eintrag benötigt 32 Byte (Tabelle 8). Daraus läßt sich dann die
    Größe des Verzeichnisses in Sektoren ausrechnen.
    Die Startadresse der Datei wird dort aber nicht mit der logischen
    Sektornummer angegeben, wie man es vielleicht erwartet hatte. Es
    taucht hier der Begriff CLUSTER auf, der in der Datei-Verwaltung eine
    wichtige Rolle spielt. Ein Sektor ist die gebräuchliche physikalische
    Einheit auf der Diskette. Der Cluster übernimmt diese Funktion für die
    Verwaltung. Er besteht normalerweise aus zwei Sektoren, deren logische
    Sektornummer hintereinander liegt. Disketten mit 180kByte (40 Tracks,
    einseitig) haben meist Cluster mit nur einem Sektor.




                                    - 9 -
     





    Da der Cluster eine 'Einheit' ist, wird für jedes File mindestens ein
    Cluster belegt. Wo wird der Cluster belegt? Jetzt kommen wir zur
    FILE-ALLOCATION-TABLE oder FAT. Dies ist eine Liste aller Cluster der
    Diskette, in der jedem Cluster die Nummer des Folgeclusters in der
    Datei zugeordnet wird. Im Klartext:
    Wenn eine Datei im Cluster 4 beginnt, steht am 4. Platz in der FAT der
    Folgecluster, d.h. der zweite Cluster der Datei z.B. eine 5. Folgt auf
    diesen Cluster kein neuer Cluster mehr folgt, steht als Folgecluster
    eine -9 (=(F)FF7h) in der FAT. Beim Lesen einer Datei hangelt sich das
    System also anhand der FAT in der Datei weiter. Eine -1 kennzeichnet
    einen zerstörten Cluster. Diese Angabe in Minus-Zahlen hat damit zu
    tun, daß auch für die FAT zwei verschiedene Formate existieren. Das
    eine Format benutzt für seine FAT-Einträge eine Zahl mit 12 Bit, das
    andere eine Zahl mit 16 Bit. Die gebräuchlichere Form ist die mit
    12Bit. Deshalb wird dieses Format als Standard benutzt. Das System
    versteht aber auch 16 Bit FATs, wenn das entsprechende Flag im BPB
    gesetzt ist. Der 16 Bit-Eintrag zeichnet sich durch eine größere
    Speicherkapazität aus, benötigt aber mehr Platz, weshalb auf normalen
    Disketten in der Regel der 12 Bit-Eintrag benutzt wird. Der ist
    übrigens etwas kompliziert aufgebaut: Je zwei Einträge bilden 3 Byte
    nach folgender Vorschrift:
    Eintrag 1: 123h
    Eintrag 2: 456h
    Byte FAT: 23 61 45h
    Die Nummerierung weist die Besonderheit auf, daß der erste
    Datencluster der Diskette immer die Nummer 2 hat, ohne Rücksicht auf
    Sektornummer o.ä. In der FAT sind die Positionen 0 und 1 mit FFFFh
    belegt.
    Wie man aus der Struktur der Datei ableitet, ist die Datei auf der
    Diskette verloren, wenn der Zusammenhalt der Cluster auf der Diskette
    in der FAT zerstört ist. Um diesem Fall X vorzubeugen, gibt es zwei
    FATs auf der Diskette. Diese liegen (Tabelle 3) allerdings
    hintereinander und meist auf dem gleichen Track, weshalb im Fall X
    dann wahrscheinlich beide FATs zugleich zerstört werden.



    Die Routinen



    Soviel zum Aufbau der Diskette. Wie läßt sich nun mit den vorhandenen
    Systemroutinen die Diskette verwalten? Dazu sind die Routinen in
    verschiedene Gruppen eingeteilt. Die Systemgruppe besteht aus
    folgenden Routinen:
    INIT      EXIT      QUERY     MEDIACH   GETBPB    FLOPRW    (RWABS)  
    FLOPFMT   VERSION
    Die genaue Beschreibung finden in Tabelle 9. Die Routine QUERY muß
    nach jedem Diskettenwechsel ausgeführt werden, um dem Controller die
    Möglichkeit zu geben, das neue Format festzustellen. Die Routine RWABS
    steht in Klammern, da sie mit der logischen Sektornummer arbeitet. Um
    diese auf die physikalische Adresse umzurechnen, benötigt das System
    allerdings den BPB, der mit der Routine SGDRIVE geholt werden muß.
    GETBPB liest allein den Boot-Sektor und errechnet den BPB, wobei
    allerdings nicht die Systemvariablen des Laufwerks aktualisiert
    werden, wie das bei SGDRIVE der Fall ist.






                                    - 10 -
     





    Allein mit der Systemgruppe kann man schon einen einfachen
    Disk-Monitor schreiben. Doch um Diskettenverzeichnisse auszuwerten,
    braucht man die Directory-Gruppe:
    SGDTA     SGDRIVE   GTPATH    SFIRST    SFIRSO    SNEXT     CHDIR    
    NAMEDTP   WRENTRY   DELETE    DCREATE   MKDIR     RMDIR
    In dieser Gruppe dreht sich fast alles um den DISK-TRANSFER-PUFFER
    (DTP, Tabelle 6). Dieser Puffer wird zur ]bergabe von Daten des
    Verzeichnisses mit dem Programm benutzt. Um die Möglichkeit des
    einfachen Umschaltens von Verzeichnissen nutzen zu können, kann mit
    der Routine SGDTA dem System die Adresse des aktuellen DTPs mitgeteilt
    werden. SGDRIVE dient zur Bestimmung des aktuellen Laufwerks, auf den
    sich alle höheren Routinen beziehen, falls es nicht in einem Namen mit
    Laufwerksangabe anders bestimmt wird. D.h. bevor eine der anderen
    Routinen durchgeführt wird, muß diese Routine benutzt werden. Dabei
    entfällt die Routine QUERY, da von SGDRIVE getestet wird, ob die
    Diskette gewechselt wurde und in diesem Falle automatisch ein QUERY
    durchführt und der BPB für das System berechnet wird.
    Wie beim IBM verwaltet BDOS die Diskette mit Unterverzeichnissen. Dies
    erfordert einige Befehle, die beim Commodore nicht bekannt sind. Die
    Unterverzeichnisse liegen verstreut auf der Diskette und werden wie
    eine Datei verwaltet. Der interne Aufbau entspricht allerdings dem
    Hauptverzeichnis. Die Unterverzeichnisse sind in einer Art
    Baumstruktur verbunden. In jedem Unterverzeichnis existiert ein
    Eintrag mit dem Namen "..", der auf das übergeordnete Verzeichnis
    zeigt. In jedem Verzeichnis können Unterverzeichnisse enthalten sein.
    Der Weg, der vom Hauptverzeichnis die Namen der Unterverzeichnisse bis
    hin zum aktuellen Verzeichnis enthält, heißt PFAD. Die Namen der
    Verzeichnisse werden mit dem 'Backslash' getrennt. Die Routine GTPATH
    liefert alle Informationen über das aktuelle Verzeichnis. Wenn man die
    Adresse eines neuen Pfades der Routine CHDIR übergibt, wird dieses
    Verzeichis als aktuelles Verzeichnis übernommen. Es wird nach dem
    Namen aber vom aktuellen Verzeichnis ausgegangen, d.h. der erste Namen
    im übergebenen Pfad muß als Unterverzeichnis im aktuellen Verzeichnis
    enthalten sein. Man kann mit z.B. "C:" am Anfang des Pfades ein
    anderes Laufwerk angeben und als aktuelles Laufwerk auswählen.
    Außerdem sagt ein Backslash vor dem Namen des ersten Verzeichnisses
    (nach dem Laufwerk), daß nicht das aktuelle Verzeichnis als
    Ausgangsverzeichnis gilt, sondern das Hauptverzeichnis. Mit der
    Routine NAMEDTP kann eine Datei (oder Unterverzeichnis) gesucht
    werden. Dazu gibt man noch das Attribut an, dem die Datei entsprechen
    muß. Dann liefert es den Startcluster der Datei, des Verzeichnisses,
    in der die Datei enthalten ist, das Laufwerk und den Pfad wieder.
    Dieser Pfad wird allerdings nicht übernommen sondern nur das Laufwerk.
    Die Unterverzeichnisse lassen sich mit den Routinen MKDIR erstellen
    und mit RMDIR (MakeDir und RemakeDir) wieder löschen. Allerdings muß
    das Verzeichnis dazu leer sein und es darf nicht das aktuelle
    Verzeichnis sein. Um in einem bestimmten Verzeichnis nun nach einem
    bestimmten Eintrag zu suchen, gibt es die Funktionen SFIRST und
    SFIRSO. Diese Routinen suchen das Verzeichnis nach einem Eintrag ab,
    der der Suchmaske aus DSNAME, DSEXT und DSATTR entspricht. Wenn ein
    Eintrag gefunden wurde, werden die DG-Parameter im DTP gesetzt, die
    das Programm dann weiter verwenden kann. SFIRST sucht nach dieser
    Maske im Hauptverzeichnis. Mit SFIRSO kann man in einem beliebigen
    Verzeichnis suchen, und es besteht die Möglichkeit, zum Anlegen einer
    neuen Datei nach einem leeren Eintrag zu suchen.







                                    - 11 -
     





    In der Suchmaske können auch die Joker "*" und "?" verwendet werden
    (nicht GSATTR). Das heißt, daß mehrere Dateien auf die Suchmaske
    passen können. SFIRST/O suchen aber nur den ersten passenden Eintrag
    im Verzeichnis. Um weitere passende Einträge zu suchen, gibt es die
    Routine SNEXT. Sie sucht immer den nächsten Eintrag, der auf die
    Suchmaske passt. Falls kein Eintrag mehr gefunden wird, kommt ein
    EntryNotFound-Fehler. Diese Routine benötigt zur ersten Durchführung
    die Initialisierung des DTP durch SFIRST/O. Im Klartext: Für den
    ersten Eintrag benutzt man immer SFIRST oder SFIRSO, alle weiteren
    sucht man mit SNEXT (siehe auch Beispielprogramm Inhaltsverzeichis).
    Hat man eine Datei gefunden und geändert (z.B. Größe und Datum) kann
    man den Eintrag mit WRENTRY auf Diskette schreiben, allerdings müssen
    vom Lesen mit SFIRST/O oder SNEXT alle Parameter gesetzt sein und es
    darf keinen Diskettenwechsel gegeben haben. Mit der Routine DCREATE
    wird z.B. eine Datei mit der Länge Null erstellt und im Verzeichnis
    speichert: Zuerst mit SFIRSO einen leeren Eintrag suchen, den Namen
    und die Länge in DGNAME/DGEXT und DG.. eintragen und mit WRENTRY
    abspeichern. DELETE löscht alle Dateien, die auf die Suchmaske im DS..
    passen, indem es die Einträge sucht, in DGNAME den ersten Buchstaben
    mit Null überschreibt und wieder mit WRENTRY speichert. Außerdem
    löscht es natürlich die Cluster, die von den Dateien vorher belegt
    wurden. Damit kommen wir zur nächsten Gruppe, den Cluster-Routinen:
    SGNEXCL   SFRCLUS   GTDSKFR
    Diese Befehle übernehmen die Verwaltung der FAT. Mit SGNEXCL kann man
    für einen Cluster aus der FAT den Folgecluster in der Datei lesen. Man
    kann aber auch einen neuen Folgecluster setzen, um eine Datei z.B. zu
    erweitern. Dazu dient auch SFRCLUS, mit der man einen freien Cluster
    suchen kann und die Nummer des Clusters oder DiskFull-Fehler erhält.
    Mit GTDSKFR kann man letztendlich die Anzahl der freien Bytes auf der
    Diskette berechnen.
    Diese Routinen werden auch von der nächsten (und bis jetzt letzten)
    Gruppe von Befehlen aufgerufen: Die Gruppe der File-Routinen:
    DOPEN     DCLOSE    DREAD     DWRITE    LSEEK
    Mit diesen Befehlen kann man normale Dateien verwalten. Um eine Datei
    zu benutzen, muß man sie als erstes mit DOPEN eröffnen. Damit erhält
    man die Adresse des FILE-PARAMETER-BLOCKs, in dem alle wichtigen Daten
    der Datei enthalten sind. Unter anderem findet sich die Handle-Nummer,
    die für das System die Funktion der File-Nummer im Commodore-Basic
    erfüllt. Diese Nummer wird bei allen anderen Funktionen angegeben, und
    das System weiß, woher es die Daten für die bestimmte Funktion nehmen
    muß. Mit DREAD kann man aus der Datei eine bestimmte Anzahl von Bytes
    aus der Datei beliebig in den Speicher laden. Mit DWRITE schreibt man
    die Daten vom Speicher auf die Diskette. DREAD und DWRITE arbeiten
    Sequentiell, d.h. es gibt einen Zeiger im FPB, der auf die Position in
    der Datei zeigt. Dieser Zeiger wird bei DREAD/DWRITE immer um die
    Anzahl der gelesenen/geschriebenen Bytes erhöht. Dieser Zeiger gibt
    dann die Adresse für den nächsten DREAD/DWRITE. Um einen relativen
    Dateizugriff zu ermöglichen, gibt es LSEEK. Damit kann dieser Zeiger
    beliebig in der Datei verschoben werden. Entweder gibt man die neue
    Position absolut oder relativ zur aktuellen Position an. Die Routine
    berechnet alle nötigen Parameter neu.
    Um sich jetzt im Umgang mit den Routinen zu üben, mögen die
    Beispielprogramme eine Hilfe sein, mit denen die wichtigsten
    Funktionen erläutert werden.








                                    - 12 -
     





    Das System ist in dieser Form in sich abgeschlossen. Es sind aber
    schon weitere Routinen und Projekte in der Planung, die aber durch die
    Jump-Tabelle leicht einzuführen sind, z.B. eine ROM-Disk, mit der man
    diverse Programme auf EPROM speichern kann. Auch ein Bildschirm-,
    Tastatur- und Druckertreiber sind geplant, zur Zeit aber nur auf dem
    Papier. Das Wesentliche an dem System, die IBM-Disketten zu verwalten,
    berühren diese Routinen nicht. Aus der Idee mit den IBM-Disketten ist
    BDOS entstanden und wird, falls ich nicht aus Faulheit auf einen
    größeren Computer umsteige, noch um einiges mehr bereichert werden.
    Doch dazu später mehr.


















































                                    - 13 -
     
